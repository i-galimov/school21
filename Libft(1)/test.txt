RUNNING TESTS:
                      First part
.-"-.     .-"-.     .-"-.     .-"-.     .-"-.     .-"-.
     "-.-"     "-.-"     "-.-"     "-.-"     "-.-"
ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK]
ft_bzero:      [OK] [OK] [OK] [OK]
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] [OK] [OK] [OK]
[no crash]: your memcpy does not segv with NULL on first params

ft_memccpy:    [MISSING]
ft_memmove:    [CRASH] [CRASH] [CRASH] [FAILED] [CRASH] [FAILED] [OK] [OK] [CRASH] [NO CRASH] [OK] [OK] [OK] [CRASH]
[crash]: your memmove does not work with basic input
[crash]: your memmove's return is false/does not work with basic input
[crash]: your memmove does not work with \0 and others unsigned char codes
[fail]: your memmove does not work with integers copy
[crash]: your memmove does not support the overlap (test 1)
[fail]: your memmove does not support the overlap (test 2)
[crash]: your memmove crash because it read too many bytes or attempt to read on dst !
[no crash]: your memmove does not segfault when null params is sent
[crash]: your memmove use malloc ? why ?

ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK]
ft_memcmp:     [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [CRASH] [OK] [OK]
[fail]: your memcmp does not work with basic input
[crash]: your memcmp crash because it read too many bytes !

ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK]
ft_isalpha:    [OK]
ft_isdigit:    [OK]
ft_isalnum:    [OK]
ft_isascii:    [OK]
ft_isprint:    [OK]
ft_toupper:    [OK]
ft_tolower:    [OK]
ft_strchr:     [FAILED] [FAILED] [FAILED] [OK] [OK] [OK] [FAILED] [OK] [OK] [NO CRASH]
[fail]: your strchr does not work with basic input
[fail]: your strchr does not work with the first char of input
[fail]: your strchr does not work with the char before \0
[fail]: your strchr does not work with \0
[no crash]: your strchr does not segfault with NULL parameter

ft_strrchr:    [FAILED] [FAILED] [FAILED] [OK] [FAILED] [OK] [CRASH] [NO CRASH]
[fail]: your strrchr does not work with basic input
[fail]: your strrchr does not work with basic input
[fail]: your strrchr does not work with not found char
[fail]: your strrchr does not work with \0
[crash]: your strrchr crash because it read too many bytes or attempt to write on s !
[no crash]: your strrchr does not segfault when a null parameter is sent

ft_strncmp:    [OK] [FAILED] [OK] [FAILED] [OK] [OK] [OK] [FAILED] [OK] [OK] [FAILED] [CRASH] [OK] [OK]
[fail]: your strncmp does not work with basic input
[fail]: your strncmp does not work with basic input
[fail]: your strncmp doesn't stop at \0
[fail]: your strncmp does not work when s1 is contained in s2
[crash]: your strncmp crash because it read too many bytes !

ft_strlcpy:    [FAILED] [FAILED] [FAILED] [FAILED] [OK] [OK] [OK]
[fail]: your strlcpy does not works with basic input
[fail]: your strlcpy does not return the good value
[fail]: your strlcpy overflow the dest
[fail]: your strlcpy does works whe size < strlen(src)

ft_strlcat:    [CRASH] [CRASH] [CRASH] [CRASH] [OK] [CRASH] [CRASH] [CRASH] [CRASH] [CRASH] [NO CRASH] [NO CRASH]
[crash]: your strlcat does not work with basic input
[crash]: your strlcat does not work with basic input
[crash]: your strlcat does not work with basic input
[crash]: your strlcat does not work with over length size
[crash]: your strcat does not work with empty string as first parameter
[crash]: your strcat does not work with empty string as second parameter
[crash]: your strlcat does not set a \0 to the end
[crash]: your strlcat crash because it read too many bytes or attempt to write on buff !
[crash]: your strlcat return value is false
[no crash]: your strlcat does not segfault when null parameter is sent
[no crash]: your strlcat does not segfault when null parameter is sent

ft_strnstr:    [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [FAILED] [CRASH] [OK] [OK]
[fail]: your strnstr does not work with basic input
[fail]: your strnstr does not work with empty strings and 0 length
[fail]: your strnstr does not work with empty strings and 0 length
[crash]: your strnstr crash because it read too many bytes !

ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [KO] [KO] [OK] [KO] [KO] [OK] run_test(58143,0x10e9b65c0) malloc: *** error for object 0x7ffb2940014a: pointer being freed was not allocated
run_test(58143,0x10e9b65c0) malloc: *** set a breakpoint in malloc_error_break to debug

[KO]: your atoi does not work with over long max value
[KO]: your atoi does not work with over long min value
[KO]: your atoi does not work with the plus sign and spaces
[KO]: your atoi does not work with the plus sign and spaces

ft_calloc:     [CRASH] [OK] [FAILED] [OK] [OK]
[crash]: your calloc don't allocate memory
[fail]: your calloc don't work with empty string

ft_strdup:     [TIMEOUT] [TIMEOUT] [OK] [TIMEOUT] [TIMEOUT] [TIMEOUT] [OK]
[timeout]: see the log file for informations
[timeout]: see the log file for informations
[timeout]: see the log file for informations
[timeout]: see the log file for informations
[timeout]: see the log file for informations


In this part, you can choose to protect your function or not to,
a color code will tell you if your function is protected/not BUT stay coherent !
[ðŸ›¡ ] --> protected
[ðŸ’¥ ] --> not protected
                     Second part
 __)(__  __)(__  __)(__  __)(__  __)(__  __)(__  __)(__  __)
(______)(______)(______)(______)(______)(______)(______)(___

ft_substr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [ðŸ’¥ ] [FAILED]
[fail]: your substr does not work when start >= ft_strlen(s)

ft_strjoin:    [OK] [OK] [FAILED] [OK] [FAILED] [ðŸ›¡ ]
[fail]: your strjoin does not work with overlap input
[fail]: your strjoin does not set \0 to the end of the string

ft_strtrim:    [OK] [FAILED] [FAILED] [FAILED] [OK] [KO] [OK] [OK] [OK] [ðŸ’¥ ]
[fail]: your strtrim does not work with basic input
[fail]: your strtrim does not work with basic input
[fail]: your strtrim does not work with full blank input
[KO]: your strtrim did not allocate the good size so the \0 test may be false

ft_split:      [FAILED] [OK] [FAILED] [FAILED] [OK] [OK] [FAILED] run_test(58300,0x10e9b65c0) malloc: Incorrect checksum for freed object 0x7ffb29500340: probably modified after being freed.
Corrupt value: 0x7ffb29500330
run_test(58300,0x10e9b65c0) malloc: *** set a breakpoint in malloc_error_break to debug
[CRASH] [OK] [FAILED] [ðŸ’¥ ]
[fail]: your split does not work with basic input
[fail]: your split does not work with one word
[fail]: your split does not work with one word
[fail]: your split will segfault in case --> *str="\0aa\0bbb" c='\0'
[crash]: your split does not work with basic input
[fail]: your split does not work with basic input

ft_itoa:       [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [CRASH]
[fail]: your itoa don't set \0 at the end of the string
[crash]: your itoa did not allocate memory for the int min value

ft_strmapi:    [CRASH] [CRASH] [CRASH] [FAILED] [OK] [ðŸ’¥ ]
[crash]: your strmapi does not work
[crash]: your strmapi does not malloc ?
[crash]: your strmapi did not set \0 at the end of the string
[fail]: your strmapi does not allocate the good size so the \0 test may be false

ft_putchar_fd: [OK] [OK]
ft_putstr_fd:  [OK] [OK] [ðŸ’¥ ]
ft_putendl_fd: [OK] [OK] [ðŸ’¥ ]
ft_putnbr_fd:  [OK] [OK] [OK] [OK] [OK]

 /~~~\/~~\/~~~\/~~~\/~~\/~~~\                    /~~~\/~~\/~~~\/~~~\/~~\/~~~\
 | /\/ /\/ /\ || /\/ /\/ /\ |                    | /\ \/\ \/\ || /\ \/\ \/\ |
  \ \/ /\/ /\/ /\ \/ /\/ /\/ /     Bonus part     \ \/\ \/\ \/ /\ \/\ \/\ \/ /
   \ \/\ \/\ \/  \ \/\ \/\ \/                      \/ /\/ /\/ /  \/ /\/ /\/ /
,_/\ \/\ \/\ \__/\ \/\ \/\ \______________________/ /\/ /\/ /\__/ /\/ /\/ /\_,
(__/\__/\__/\____/\__/\__/\________________________/\__/\__/\____/\__/\__/\__)

ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
ft_striteri:   [OK] [OK] [ðŸ›¡ ] dyld: warning: could not load inserted library './assets/malloc.dylib' into hardened process because no suitable image found.  Did find:
	./assets/malloc.dylib: code signature in (./assets/malloc.dylib) not valid for use in process using Library Validation: mapped file has no cdhash, completely unsigned? Code has to be at least ad-hoc signed.
	./assets/malloc.dylib: stat() failed with errno=1